# Portable Code Generation Design

The basic scheme is that as few portions of the compiler as possible are written
in assembly for the various platforms. The Forth engine is generated by a
portable Forth program, which outputs an assembly file suitable for handing to
GCC or Clang.

## Basic Plan

For each architecture/platform pair, we have straight assembly headers and
footers, and Forth files that follow a standard interface but generate different
code.

Essentially we're using Forth as a macro assembler, with a cleverly designed set
of macros to eg. push or pop from the stack into a scratch register.

Each platform has a Forth file, which is loaded before the main engine.

The result is a (vaguely human-readable) `.s` assembly file that can be compiled
on the target platform.


## Cross-compilation

In order to port the system to new devices, it's handy for it to be able to
target platforms other than the current one.

That's straightforward - there's no reason why the macro files loaded need to be
those for this platform!



## Detailed Design Notes

### Stack, Memory and Registers

Some of the most basic fundamental ops are for dealing with the stacks and
memory.

Every architecture defines macros for pushing and popping to and from registers,
for both the data and return stacks.

Both also define macros for dereferencing a pointer, writing to a pointer, and
so on.


### Primitives

The following is an attempt at a complete list of all the required primitives,
that is, words that need to be written directly in the engine, and not in the
Forth library.

- Math: `+` `-` `*` `/` `MOD` `U/` `UMOD`
- Bitwise: `AND` `OR` `XOR` `LSHIFT` `RSHIFT`
- Comparison: `<` `=` `U<`
- Stack: `DUP` `SWAP` `DROP` `SP@` `SP!` (Minimally. `OVER` `ROT` `-ROT` and
  `2foo` might be useful/fast as well)
- Return Stack: `>R` `R>` `R@` `RP@` `RP!`
- Memory: `@` `!` `C@` `C!` `(>HERE)` (or some similar scheme for the data space
  pointer?)
- Branching: See below.
- Sizing: `CELLS` `CHARS` (or similar)
- Defining: `:` `;` `CREATE` `DOES>` `:NONAME`
- Misc: `EXECUTE` `>BODY`
- Literals: `(DOLIT)` `(DOSTRING)` or similar.
- Calls: `(CALL)` (for calling other non-primitives) and maybe `(C-CALL)` for
  calling C functions?

That's a pretty long list, and it's not quite minimal.


### Labels and Branching

Labels are the assembler's problem, basically. We simply emit them with
ascending numbers, and let the assembler sort them out. The label's number
(name?) is passed around by the Forth macro that's generating a word.

Basic plan is for 6 primitives:

- `(MAKE-LABEL) ( -- label )` introduces a new label without compiling anything.
- `[0branch-fwd] ( -- label )` conditionally branches forward. introduces a new
  label for its target.
- `[branch-fwd] ( -- label )` unconditionally branches forward. new label.
- `(RESOLVE-LABEL) ( label -- )` resolves a previous label to point to here
- `[0branch-bwd] ( label -- )` conditionally branches backward to an
  already-defined label
- `[branch-bwd] ( label -- )` unconditionally branches backward to an
  already-defined label

With those (actually all 6 might not be needed in practice) any control flow
can be implemented.


### Calling C Functions

There will be a family of macros for doing C calls, probably:

- `CALL-ARG-PRE ( #args -- )` - Called first, to set up any necessary rules.
- `CALL-ARG! ( arg i -- )` - Prepares `arg` to be the `i`th argument.
- `CALL ( c-addr u -- )` - Calls the named C function.
- `CALL-RETURN ( -- reg )` - Loads the return value into a canonical register,
  and returns which one.

**NB:** Any subset of the scratch registers may be overwritten by a C call!

**TODO:** Probably we'll want to support dlopen() and similar with additional
macros, to support runtime-declared C calls in the user code. But that's an
advanced feature that can wait for the future.



